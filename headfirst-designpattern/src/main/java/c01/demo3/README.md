我们知道Duck类内的fly()和quack会随着鸭子的不同而改变。

为了要把这两个行为从Duck类中分开，我们将把它们从Duck类中取出来，建立
一组新类来代表每个行为。

我们利用接口代表每个行为，而行为的每个实现都将实现其中的一个接口。

所以这次鸭子类不会负责实现这些接口，反而是由我们制造一组其他类专门实
现这些接口，这就称为"行为"类。由行为类而不是Duck类来实现行为接口。

以往的做法是：行为来自超类的具体实现，或是继承某个接口并由子类自行实
现而来。这两种做法都是依赖于"实现"，我们被实现绑的死死的，没办法更改
行为(除非写更多代码)。

在我们的新设计中，鸭子的子类将使用接口所表示的行为，所以实际的"实现"
不会被绑死在鸭子的子类中。(换句话说，特定的具体行为编写在实现了行为
接口的类中)。

这样，鸭子类就不再需要知道行为的实现细节。

这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为
已经与鸭子类无关了。

而我们可以新增一些行为，不会影响到既有的行为类，也不会影响"使用"到
飞行行为的鸭子类。

这样一来，有了继承的"复用"的好处，却没有继承所带来的包袱。