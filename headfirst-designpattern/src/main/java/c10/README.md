### OO 模式
状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改
了它的类。

因为将状态封装称为独立的类，并将动作委托到代表当前状态的对象，我们
知道行为会随着内部状态而改变。从客户端的视角来看，如果说你使用的对
象能够完全改变它的行为，那么你会觉得，这个对象实际上是从别的类实例
化而来的。然而，实际上，你知道我们是在使用组合通过简单引用不同的状
态对象来造成类改变的假象。

以状态模式而言，我们将一群行为封装在状态对象中，context的行为随时
可委托到那些状态对象中的一个，随着时间的流逝，当前状态在状态对象
集合中游走改变，以反映出context内部的状态，因此，context的行为也会
跟着改变。但是context的客户对于状态对象了解不多，甚至根本是浑然不
觉。

而以策略模式而言，客户通常主动指定context所要组合的策略对象是哪一
个。现在，固然策略模式让我们具有弹性，能够在运行时改变策略，但对于
某个context对象来说，通常都只有一个最恰当的策略对象。

一般来说，我们把策略模式想成是除了继承之外的一种弹性替代方案。如果
你使用继承定义了一个类的行为，你将被这个行为困住，甚至要修改它都很
难。有了策略模式，你可以通过组合不同的对象来改变行为。

我们把状态模式想成是不用在context中放置许多条件判断的替代方案。通过
将行为包装进状态对象中，你可以通过在context内简单地改变状态对象来改
变context的行为。

策略模式是围绕可以互换的算法来创建成功业务的。状态模式是通过改变对
象内部的状态来帮助对象控制自己的行为。

状态的转换并不一定要通过状态来决定，Context也可以决定状态转换的流向。
一般来讲，当状态转换是固定的时候，就适合放在Context中；然而，当转换
是更动态的时候，通常就会放在状态类中。将状态转换放在状态类中的缺点
是：状态类之间产生了依赖。请注意，在做这个决策的同时，也等于是在为
另一件事情做决策：当系统进化时，究竟哪个类是对修改封闭(Context还是
状态类)的。

客户端不会直接和状态交互。状态是用在Context中来代表它的内部状态以及
行为的，所以只有Context才会对状态提出请求。客户不会直接改变Context
的状态，全盘了解状态是Context的工作，客户根本不了解，所以不会直接
和状态联系。

在个别的状态类中封装状态行为，结果总是增加这个设计中类的数目。这就
是为了要获取弹性而付出的代价。其实状态模式的设计是绝对值得的。其实
真正重要的是你暴露给客户的类数目，而且我们有办法将这些额外的状态类
全部隐藏起来。如果有一个应用，它有很多状态，但是不将这些状态封装在
不同的对象中，那么就会得到巨大的、整块的条件语句。这会让代码不容易
维护和理解。通过使用许多对象，你可以让状态变得很干净，在以后理解和
维护它们时，就可以省下很多的工夫。

如果我们没有共同的功能可以将状态设计为接口。在实现状态模式时，很可
能使用抽象类。这样一来，当你以后需要在抽象类中加入新的方法时就很容
易，不需要打破具体状态的实现。

### 要点
* 状态模式允许一个对象基于内部状态而拥有不同的行为。
* 和程序状态机不同，状态模式用类代表状态。
* Context会将行为委托给当前状态对象。
* 通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了。
* 状态模式和策略模式有相同的类图，但是它们的意图不同。
* 策略模式通常会用行为或算法配置Context类。
* 状态模式允许Context随着状态的改变而改变行为。
* 状态转换可以有State类或Context类控制。
* 使用状态模式通常会导致设计中类的数目大量增加。
* 状态类可以被多个Context实例共享。