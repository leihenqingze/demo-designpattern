### OO 模式

代理模式：为另一个对象提供一个替身或占位符以**控制**对这个对象的**访问**。

Subject，它为RealSubject和Proxy提供了接口。通过实现同一个接口，Proxy
在RealSubject出现的地方取代它。

RealSubject是真正做事的对象，它是被Proxy代理和控制访问的对象。

Proxy持有RealSubject的引用。在某些例子中，Proxy还会负责RealSubject
对象的创建与销毁。客户和RealSubject的交互都必须通过Proxy。因为Proxy
和RealSubject实现相同的接口(Subject)，所以任何用到RealSubject的地
方，都可以用Proxy取代。Proxy也控制了对RealSubject的访问，在某些情况
下，我们可能需要这样的控制。这些情况包括RealSubject是远程的对象、
RealSubject创建开大，或RealSubject需要被保护。

代理模式有许多变体，这些变体都有共通点：都会将客户对主题施加的方法
调用拦截下来。这种间接的级别让我们可以做许多事，包括将请求分发到远
程主题；给创建开销大的对象提供代表；或者提供某些级别的保护，这种保
护能决定哪些客户能调用哪些方法。

看上去装饰器和代理模式基本上都是用一个对象把另一个包起来，然后把调
用委托给实际对象。但是它们的目的(意图)是不一样的。装饰者为对象增加
行为，而代理是控制对象的访问。代理有时候会创建对象，而装饰器从来不
实例化任何东西。

要如何让客户使用代理，而不是真正的对象？一个常用的技巧是提供一个工
厂，实例化并返回主题。因为这是在工厂方法内发生的。我们可以用代理包
装主题再返回，而客户不知道也不在乎他使用的是代理还是真东西。

代理和适配器都是挡在其他对象的前面，并负责将请求转发给它们。适配器
会改变对象适配器的接口，而代理则实现相同的接口。

### 要点
* 代理模式为另一个对象提供代表，以便控制客户端对对象的访问，管理访问
的方式有许多种。
* 代理在结构上类似装饰者，但是目的不同。
* 装饰者模式为对象加上行为，而代理则是控制访问。
* Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到
所选的处理器。
* 就和其他的包装者一样，代理会造成你的设计中类的数目增加。

### 常见代理
* 远程代理管理客户和远程对象之间的交互(控制访问远程对象)。
* 虚拟代理控制访问实例化开销大的对象。
* 保护代理基于权限(调用者)控制对对象方法(资源)的访问。
* 缓存代理：为开销大的运算结果提供暂时存储，它也允许多个客户共享结
果，以减少计算或网络延迟。常用于Web服务器代理，以及内容管理与出版系
统。
* 同步代理：在多线程的情况下为主题提供安全的访问。为分散式环境内的
潜在对象集合提供同步访问控制。
* 防火墙代理：控制网络资源的访问，保护主题免于"坏客户"的侵害。
* 写入时候复制代理：用来控制对象的复制，方法是延迟对象的复制，直到
客户真的需要为止。这是虚拟代理的变体。
复杂隐藏代理：用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有
时候也称为外观代理，这不难理解，复杂隐藏代理和外观模式是不一样的，
因为代理控制访问，而外观模式只提供另一组接口。
* 智能引用代理：当主题被引用时，进行额外的动作，例如计算一个对象被
引用的次数。