本章通过一个烤肉的例子对命令模式进行了讲解。

在例一中由于客户和烤羊肉串老板的'紧耦合'所以使得容易出错，
容易混乱，也容易挑剔。这其实就是'行为请求者'和'行为实现者'的紧耦合。
对请求排队或记录请求日志，以及支持可撤销的操作等行为时，
'行为请求者'和'行为实现者'的紧耦合是不太合适的。

在例二中我们不用去认识烤肉者是谁，连他的面都不用见到，
我们只需要给接待我们的服务员说我们要什么就可以了。
他可以记录我们的请求，然后再由他去通知烤肉师傅做。
而且，由于我们所做的请求，其实也就是我们点肉的订单，
上面有很详细的我们的要求，所有的客户都有这一份订单，
烤肉师傅可以按先后顺序操作，不会混乱，也不会遗忘了。

其中不管是烤羊肉串，还是烤鸡翅，还是其他烧烤，这些都是'烤肉串者类'的行为，
也就是他的方法，具体怎么做都是由方法内部来实现，我们不用去管它。
但是对于'服务员'类来说，他其实就是根据用户的需要，发个命令，说：
'有人要十个羊肉串，有人要两个鸡翅'，这些都是命令...。

把'烤肉者串'类当中的方法，分别写成多个命令类，那么它们就可以被'服务员'来请求了。
这些命令其实差不多都是一个样式，于是就可以泛化出一个抽象类，
让'服务员'只管对抽象的'命令'发号施令就可以了，具体是什么命令，即烤什么，由客户来决定吧。

在例三中：
第一，真实的情况其实并不是用户点一个菜，服务员就通知厨房去做一个，
那样不科学，应该是点完烧烤后，服务员一次通知制作；
第二，如果此时鸡翅没了，不应该是客户来判断是否还有，客户哪知道有没有啊，
应该是服务员或烤肉串者来否决这个请求；(明确职责)
第三，客户到底点了哪些烧烤或饮料，这是需要记录日志的，以备收费，
也包括后期的统计；
第四，客户完全有可能因为点的肉串太多而考虑取消一些还没有制作的肉串。

命令模式：将一个请求封装为一个对象，
从而使你可用不同的请求对客户进行参数化；
对请求排队或记录请求日志，以及支持可撤销的操作。

优点：
1. 它能较容易地设计一个命令队列；
2. 在需要的情况下，可以较容易地将命令记入日志。
3. 允许接收请求的一方决定是否要否决请求。
4. 可以容易地实现对请求的撤销和重做。
5. 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。
6. 把请求一个操作的对象与知道怎么执行一个操作的对象分割开。

碰到上面类似的功能也不一定要使用命令模式，
比如命令模式支持撤销/恢复操作功能，
但如果不清楚是否需要，就先不要实现命令模式。

敏捷开发原则告诉我们，不要为代码添加基于猜测的、
实际不需要的功能。如果不清楚一个系统是否需要命令模式，
一般就不要着急去实现它，事实上，
在需要的时候通过重构实现这个模式并不困难，
只有在真正需要如撤销/恢复操作等功能时，
把原来的代码重构为命令模式才是有意义。

![命令模式](https://github.com/leihenqingze/fodder/blob/master/demo-designpattern/bigtalk-designpattern/c23/commandpattern.png?raw=true)

