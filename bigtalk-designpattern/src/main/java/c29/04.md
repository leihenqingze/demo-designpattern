“我觉得，抽象工厂可以解决多个类型产品的创建问题，就我而言，同一对象与多个数据库ORM就是通过她来实现的。我觉得她会赢。”Hibernate坚定地说。

“你也不看看，抽象工厂那形象，多臃肿呀，身上类这么多。做起事来一定不够利索。”ADO.NET不喜欢抽象工厂。

“那你喜欢单例？”Hibernate问道。

“单例又太瘦了。过于骨感也不是美。我其实蛮喜欢原型那小姑娘的，我的DataSet只要调用原型模式的Clone就可以解决数据结构的复制问题，而Copy则不但复制了结构，连数据也都复制完成，很是方便。”

“那你不觉得建造者把建造过程隐藏，一个请求，完整产品就创建，在高内聚的前提下使得与外界的耦合大大降低，这不也是很棒的吗？”

“问题是又有多少产品是相同的建造过程呢？再说回来，你造什么对象，不还是需要new吗？”

“哈，从new的角度讲，工厂方法才是最棒的设计，它可是把工厂职责都分了类了，其他几位不过是她的变体罢了。”

“有点道理，看来创建型这一组，工厂方法有点优势哦。”

“下面有请评委提问。”主持人GOF待五位选手出场亮相之后接着说。

“请问抽象工厂小姐，为什么我们需要创建型模式？”开放-封闭先生问道。

只见抽象工厂思考了一下，说道：“我觉得创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性[DP]。”

“请问原型小姐，你有什么补充？”依赖倒转对着原型问道。

原型显然没想到突然会问到她，而且对于这个问题，多少有点手足无措，她说：“当一个系统应该独立于它的产品创建、构成和表示时，应该考虑用创建性模式。建立相应数目的原型并克隆它们通常比每次用合适的状态手工实例化该类更方便一些[DP]。”

“哈，这可能是我们需要原型的理由。”依赖倒转说道，然后转头问建造者，“请谈谈你对松耦合的理解。”

建造者对这个问题一定是有了准备，不慌不忙，说道：“这个问题首先要谈谈内聚性与耦合性，内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合[DPE]。”

“那么你自己是如何去实践松耦合的呢？”依赖倒转接着问。

“我是将一个复杂对象的构建与它的表示分离，这就可以很容易地改变一个产品的内部表示，并且使得构造代码和表示代码分开。这样对于客户来说，它无需关心产品的创建过程，而只要告诉我需要什么，我就能用同样的构建过程创建不同的产品给客户[DP]。”

“回答得非常好，现在请问单例，你来说说看你参赛的理由，你与别人有何不同？”单一职责问道。

单例小姐有些羞涩，停了一会，才开口说：“我觉得对一些类来说，一个实例是很重要的。一个全局变量可以使得一个对象被访问，但它不能防止客户实例化多个对象。我的优势就是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且我还提供了一个访问该实例的方法。这样就使得对唯一的实例可以严格地控制客户怎样以及何时访问它[DP]。”

“工厂方法，请问你如何理解创建型模式存在的意义？”合成聚合复用问道。

此时只听场下一声音叫道，“二姐加油”，原来简单工厂在观众席上喊叫呢。工厂方法对着观众席微笑了一下，然后非常有信心地答道，“创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定。[DP]”

“那么请问你与其他几位创建型模式相比有什么优势？”

“我觉得她们几位都可能设计出比我更加灵活的代码，但她们的实现也相对就更加复杂。通常设计应该是从我，也就是工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。[DP]”

几位评委都在不住地点头，显然，他们非常肯定工厂方法的回答。《大话设计模式》

“下面有请几位评委写上您们认为表现最好的模式小姐。”GOF说道。

“单一职责先生，您的答案是？”

只见单一职责翻转纸牌，上面写着“单例”。

“非常好，单例小姐已有一票。”

“开放封闭先生，您的选择是？”

“工厂方法。我觉得工厂方法能使得我们增加新的产品时，不需要去更改原有的产品体系和工厂类，只需扩展新的类就可以了。这对于一个模式是否优秀是非常重要的判断标准，我选择她。”开放封闭说道。