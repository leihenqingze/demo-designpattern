“请问观察者小姐，说说你对解除对象间的紧耦合关系的理解？”依赖倒转问道。

“我觉得对象间，尤其是具体对象间，相互知道的越少越好，这样发生改变时才不至于互相影响。对于我来说，目标和观察者不是紧密耦合的，它们可以属于一个系统中的不同抽象层次，目标所知道的仅仅是它有一系列的观察者，每个观察者实现Observer的简单接口，观察者属于哪一个具体类，目标是不知道的。”

“非常好，请问模板方法小姐，请你谈谈，你对代码重复的理解以及你如何实现代码重用？”里氏代换问。

模板方法说，“代码重复是编程中最常见、最糟糕的‘坏味道’，如果我们在一个以上的地方看到相同的程序结构，那么可以肯定，设法将它们合而为一，程序会变得更好[RIDEC]。但是完全相同的代码当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中[R2P]，这使得我们一定要小心处理。继承的一个非常大的好处就是你能免费地从基类获取一些东西，当你继承一个类时，派生类马上就可以获得基类中所有的功能，你还可以在它的基础上任意增加新的功能。模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法[DPE]。这样就使得，所有可重复的代码都提炼到抽象类中了，这就实现了代码的重用。”

“下面请问命令小姐，为什么要将请求发送者与具体实现者分离？这有什么好处？”单一职责问道。

“您的意思其实就是将调用操作的对象与知道如何实现该操作的对象解耦，而这就意味着我可以在这两者之间处理很多事，比如完全可以发送者发送完请求就完事了，具体怎么做是我的事，我可以在不同的时刻指定、排列和执行请求。再比如我可以在实施操作前将状态存储起来，以便支持取消/重做的操作。我还可以记录整个操作的日志，以便以后可以在系统出问题时查找原因或恢复重做。当然，这也就意味着我可以支持事务，要么所有的命令全部执行成功，要么恢复到什么也没执行的状态。总之，如果有类似的需求时，利用命令模式分离请求者与实现者，是最明智的选择。”

“OK，职责链小姐，提问命令小姐的问题同样提问给你，为什么要将请求发送者与具体实现者分离？这有什么好处？你如何回答。”

“我们时常会碰到这种情况，就是有多个对象可以处理一个请求，哪个对象处理该请求事先并不知道，要在运行时刻自动确定，此时，最好的办法就是让请求发送者与具体处理者分离，让客户在不明确指定接收者的情况下，提交一个请求，然后由所有能处理这请求的对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。”职责链答道，“比如我住在县城，生了怪病，我不知道什么级别的医院可以诊治，显然最简单的办法就是马上找附近的医院，让此医院来决定是否可以治疗，如果不能则医院会提供转院的建议，由县级转市级、由市级转省级、由省级转国家级，反正直到可以治疗为至。这就不需要请求发送者了解所有处理者才能处理问题了。”

“非常好，例子很形象，不过得怪病不是好事，健康才最重要。”开放封闭微笑道，“下面请问最后一位，状态小姐，条件分支的大量应用有何问题？如何正确看待它？”

状态答道：“如果条件分支语句没有涉及重要的商务逻辑或者不会随着时间的变化而变化，也不会有任何的可扩展性，换句话说，它几乎不会变化，此时条件分支是应该使用的。但是注意我这里用到了很多前提，这些前提往往都是不成立的，事实上不会变化的需求很少，不需要扩展的软件也很少，那么如果把这样的分支语句进行分解并封装成多个子类，利用多态来提高其可维护、可扩展的需要，是非常重要的。状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的if或switch中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换。[DP]”

MVC是包括三类对象，Model是应用对象，View是它在屏幕上的表示，Controller定义用户界面对用户输入的响应方式。如果不使用MVC，则用户界面设计往往将这些对象混在一起，而MVC则将它们分离以提高灵活性和复用性。

MVC是多种模式的综合应用，应该算是一种架构模式。