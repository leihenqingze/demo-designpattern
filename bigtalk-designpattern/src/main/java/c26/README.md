享元模式：运用共享技术有效地支持大量细粒度的对象。

FlyweightFactory根据客户需求返回早已生成好的对象，但实际上不一定
需要事先生成对象的实例，完全可以初始化时什么也不做，到需要时，
再去判断对象是否为null来决定是否实例化。

尽管大部分时间需要共享对象来降低内存的损耗，但个别时候也有可能不需要共享的，那么此时的UnsharedConcreteFlyweight子类就有存在的必要了，它可以解决那些不需要共享对象的问题。

在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对
象的内部状态，而随环境改变而改变的、不可以共享的状态就是外部状态了。

享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大
量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上
都是相同的，有时就能够大幅度地减少需要实例化的类的数量。如果能把
那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过
共享大幅度地减少单个实例的数目。

也就是说，享元模式Flyweight执行时所需要的状态是有内部的也可能有外部的，
内部状态存储于ConcreteFlyweight对象之中，而外部对象则应该考虑由客户端
对象存储或计算，当调用Flyweight对象的操作时，将该状态传递给它。

外部状态，应该由专门的对象来处理。

如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储
开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果
删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，
此时可以考虑使用享元模式。

因为用了享元模式，所以有了共享对象，实例总数就大大减少了，如果共享
的对象越多，存储节约也就越多，节约量随着共享状态的增多而增大。

在某些情况下，对象的数量可能会太多，从而导致了运行时的资源与性能损耗。
那么我们如何去避免大量细粒度的对象，同时又不影响客户程序，是一个值得
去思考的问题，享元模式，可以运行共享技术有效地支持大量细粒度的对象。
不过，使用享元模式需要维护一个记录了系统已有的所有享元的列表，
而这本身需要耗费资源，另外享元模式使得系统更加复杂。为了使对象可以
共享，需要将一些状态外部化，这使得程序的逻辑复杂化。因此，应当在有
足够多的对象实例可供共享时才值得使用享元模式。

也可能需要考虑并发问题，有可能对象的内外状态拆分之后都可以共享。

实际应用：
1. String对象
2. 围棋、五子棋、跳棋等

围棋和五子棋只有黑白两色、跳棋颜色略多一些，但也是不太变化的，所以
颜色应该是棋子的内部状态，而各棋子的差别主要就是位置的不同，所以
方位坐标应该是棋子的外部状态。

像围棋，一盘棋理论上有361个空位可以放棋子，那如果用常规的面向对象方
式编程，每盘棋都可能有两三百个棋子对象产生，一台服务器就很难支持更
多的玩儿家玩围棋游戏了，毕竟内存空间还是有限的。如果用了享元模式来
处理棋子，那么棋子对象可以减少到只有两个实例。这的确是非常好地解决
了对象的开销问题。

![享元模式](https://github.com/leihenqingze/fodder/blob/master/demo-designpattern/bigtalk-designpattern/c26/flyweight.png?raw=true)