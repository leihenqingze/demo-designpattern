### A.2 类与实例：
一切事物皆为对象，即所有的东西都是对象，对象就是可以看到，感觉到，
听到，触摸到，尝到，或闻到的东西。**对象是一个自包含的实体，用一组可识
别的特性和行为来标识。**

面向对象编程，其实就是针对对象进行编程的意思。

类就是具有相同的属性和功能的对象的抽象的集合。

### A.3 构造方法
构造方法，又叫构造函数，其实就是对类进行初始化。

### A.4 方法重载
方法重载好处是可在不改变原方法的基础上，新增功能。
方法重载算是提供了函数可扩展的能力。

并不是必须要在实例化的时候就声明的，这时候应该考虑用'属性'。

### A.5 属性与修饰符
如果private字段的get/set方法仅仅是可读可写，那与声明了public的字段没
什么区别。但是对于外界公开的数据，我们通常希望能做更多的控制。

我们并不是让所有的人都可以从门随意进出，也不希望蚊子苍蝇来回出入。
这就是属性的作用了，如果你把字段声明为public，那就意味着不设防的门窗，
任何时候，调用者都可以读写，这是非常糟糕的一件事，如果把对外的数据写
成属性，那情况就会好很多。多了层控制就多了层保护，

一般无需要对外界公开的方法都应该设置其修饰符为private，这样才有利于'封装'。

### A.6 封装
面向对象的三大特性之一封装

每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装。因此
对象不必依赖其他对象来完成自己的操作，这样方法和属性包装在类中，
通过类的实例来实现。

封装有很多的好处，
第一，良好的封装能够减少耦合。
第二，类内部的实现可以自由的修改。
第三，类具有清晰的对外接口。

### A.7 继承
面向对象的三大特性之二继承

对象的继承代表了一种“is-a”的关系，如果两个对象A和B，可以描述为
‘B是A’,则表明B可以继承A，继承者还可以理解为是对被继承者的特殊化，
因为它除了具备被继承者的特性外，还具备自己独有的个性。

在继承关系中，继承者可以完全替换被继承者，反之，则不成立。

继承定义了类如何相互关联，共享特性。继承的工作方式是，定义父类和子类，
或叫做基类和派生类，其中子类继承父类的所有特性。子类不但继承了父类的
所有特性，还可以定义新的特性。

学习继承最好记住三句话：
如果子类继承父类，
第一，子类拥有父类非private的属性和功能；
第二，子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能；
第三，子类还可以以自己的方式实现父类的功能（方法重写）。

不用继承的话，如果要修改功能，就必须在所有重复的方法中修改，代码越多，
出错的可能就越大，而继承的优点是，继承使得所有子类公共的部分都放在了
父类，使得代码得到了共享，这就避免了重复，另外，继承可使得修改或扩展
继承而来的实现都较为容易。

继承是有缺点的，那就是父类变，则子类不得不变。
继承会破坏包装，父类实现细节暴露给子类，这其实是增大了两个类之间的
耦合性。

耦合性：简单理解就是藕断丝连，两个类尽管分开，但如果关系密切，一方
的变化都会影响到另一方，这就是耦合性高的表现，继承显然是一种类与类
之间强耦合的关系。

什么时候使用继承？当两个类之间具备“is-a”的关系时，就可以考虑用继承
了，因为这表示一个类是另一个类的特殊种类，而当两个类之间具备“has-a”
的关系时，表示某个角色具有某一项责任，此时不合适用继承，比如人有两只
手，手不能继承人，再比如飞机场有飞机，这飞机也不能去继承飞机场。

### A.8 多态
面向对象的三大特性之三多态

多态表示不同的对象可以执行相同的动作，但要通过他们自己的实现代码来执行。

有几点要注意：
第一，子类以父类的身份出现。
第二，子类在工作时以自己的方式来实现。
第三，子类以父类的身份出现时，子类特有的属性和方法不可以使用。

不同的对象可以执行相同的动作，但要通过他们自己的实现代码来执行。

注意：
这个对象的声明必须是父类，而不是子类，实例化的对象是子类，这才能实现
多态，多态的原理是方法被调用时，无论对象是否被转换为其父类，都只有位
于对象继承链最末端的方法实现会被调用，也就是说，虚方法是按照其运行时
类型而非编译时类型进行动态绑定的。

> 在计算机中非动态绑定比动态绑定的执行效率高一些， C#中用虚方法来声
明需要动态绑定的方法，而其他方法就可以使用非动态绑定，这是一种优化。

### A.10 抽象类
Animal类其实根本就不可能实例化的，
我们完全可以考虑把实例化没有任何意义的父类，改成抽象类，对于方法体
没有任何意义的，我们可以考虑将其变为抽象方法。C#允许把类和方法声明
为abstract，即抽象类和抽象方法。

抽象类需要注意几点：
第一，抽象类不能实例化。
第二，抽象方法是必须被子类重写的方法，不重写的话，
它的存在没有任何的意义。
第三，如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含
其他一般方法。

我们应该考虑让抽象类拥有尽可能多的共同代码，拥有尽可能少的数据。

抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的
抽象类时，一定是用来继承的，所以，在一个以继承关系形成的等级结构里面，
树叶节点应当是具体类，而树枝节点均应当是抽象类。也就是说，具体类不是
用来继承的，我们作为编程设计者，应该要努力做到这一点。当然这也需要
具体情况具体分析的。

### A.11 接口

接口是把隐式公共方法和属性结合起来，以封装特定功能的一个集合，一旦
类实现了接口，类就可以支持接口所指定的所有属性和成员，声明接口在语
法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式。
所以接口不能实例化，不能有构造函数和字段，不能有修饰符，比如public,
private等，不能声明虚拟的或动态的。还有实现接口的类就必须要实现接口
中的所有方法和属性。

一个类可以支持多个接口，多个类也可以支持相同的接口。

抽象类和接口的区别：
抽象类可以给出一些成员的实现，接口却不包含成员的实现，抽象类的抽象
成员可被子类部分实现，接口的成员需要实现类完全实现，一个类只能继承
一个抽象类，但可实现多个接口等等。

但这些都是从两者的形态上区分的。我觉得还有三点是能帮助我们去区分抽象类和接口的。
第一，类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象。
接口是对类的局部（行为）进行的抽象，而抽象类是对类整体（字段，属性，
方法）的抽象，如果只关注行为抽象，那么也可以认为接口就是抽象类。
总之，不论是接口，抽象类，类甚至对象，都是在不同的层次，不同的角度
抽象的结果。他们的共性就是抽象。
第二，如果行为跨越**不同类型**的对象，可使用接口。对于一些相似的类对
象，用继承抽象类。
实现接口和继承抽象类并不冲突
第三，从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，
然后子类继承父类，而接口是根本不知道子类的存在，方法如何实现还不确认，
预先定义。这里其实说明的是抽象类和接口设计的思维过程。回想一下我们
今天刚开始讲的时候，先是有一个Cat类，然后再有一个Dog类，观察后发现
他们有相似之处，于是泛化出Animal类，这也体现了敏捷开发的思想，通过
重构改善既有代码的设计。事实上，只有小猫的时候，然后就去设计一个动
物类，这就会有可能成为过度设计了。抽象类往往是通过重构得来的。如果
事先意识到多种分类的可能，那么事先就设计出抽象类也是完全可以的。
但是接口就不是那么回事了，比如我们是动物运动会的主办方，在策划时，
大家就坐在一起考虑需要组织什么样的比赛，大家商议后，觉得应该设置如
跑的快、跳的高、飞的最远等等比赛项目，而此时，主办方其实还不清楚会
有什么样的动物来参加运动会，所有的这些比赛项目都可能是完全不相同的
动物在比，它们将如何去实现这些行为也不得而知，此时，能做的就是事先
定义这些比赛项目的行为接口。

抽象类时自底而上抽象出来的，而接口则是自顶向下设计出来的。

### A.11.集合
数组优点：数组在内存中连续存储,因此可以快速而容易地从头到尾遍历元素，
可以快速修改元素等等。
数组缺点：创建时必须要指定数组变量的大小，还有在两个元素之间添加元
素也比较困难。数组长度设置过大，造成内存空间浪费，长度设置过小造成
溢出。

.NET 提供了用于数据存储和检索的专用类，这些类统称为集合。这些类提供
对堆栈，队列，列表和哈希表的支持，大多数集合类实现相同的接口。

ArrayList是命名空间System.Collections下的一部分，它是使用大小可按需
动态增加的数组实现List接口。
ArrayList的容量是ArrayList可以保存的元素数，ArrayList的默认初始容量
为0，随着元素添加到ArrayList中，容量会根据需要通过重新分配自动增加。
使用整数索引可以访问此集合中的元素。此集合中的索引从0开始。

数组的容量是固定的，ArrayList的容量可根据需要自动扩充。

集合的变化是影响全局的，它始终都保证元素的连续性。

ArrayList的不足：ArrayList不管你是什么对象都是接受的，因为在它眼里
所有元素都是Object,换句话说，ArrayList不是类型安全的，还有就是
ArrayList对于存放值类型的数据，比如int,String型（String是一种拥有值
类型特点的特殊引用类型）或者结构struct的数据，用ArrayList就意味着都
需要将值类型装箱为Object对象，使用集合元素时，还需要执行拆箱操作，
这就带来了很大的性能损耗。

相对于简单的赋值而言，装箱和拆箱过程需要进行大量的计算，对值类型进
行装箱时，必须分配并构造一个全新的对象，其次，拆箱所需的强制转换也
需要进行大量的计算。总之，装箱和拆箱是耗资源和时间的，而ArrayList
集合在使用值类型数据时，其实就是在不断地装箱和拆箱的工作，这显然是
非常糟糕的事情。

### A.13.泛型
泛型是具有占位符（类型参数）的类，结构，接口和方法，这些占位符是类，
结构，接口和方法所存储或所使用的一个或多个类型的占位符。泛型集合类
可以将类型参数用作它所存储的对象的类型的占位符，类型参数作为其字段
的类型和其方法的参数类型出现。

通常情况下，都建议使用泛型集合，因为这样可以获得类型安全的直接优点
而不需要从基集合类型派生并实现类型特定的成员。此外，如果集合元素为
值类型，泛型集合类型的性能通常优于对应的非泛型集合类型（并优于从非
`泛型集合类型派生的类型），因为使用泛型时不必对元素进行装箱。

### A.14 委托和事件
委托是对函数的封装，可以当作给方法的特征指定一个名称。而事件则是
委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程。
事件其实就是设计模式中观察者模式在.NET中的一种实现方式。

委托是一种引用方法的类型，一旦为委托分配了方法，委托将与该方法具
有完全相同的行为。

事件是说在发生其他类或对象关注的事情时，类或对象可通过事件通知它们。

### 总结
根据职责的不同将不同的代码封装在各个对象中，一是对象与需求空间的概念
相一致，二是也体现了职责的分离。这使得代码的概念和职责更清晰，从而使
得代码更容易维护。

对象与对象之间共性的问题可以用类来表示，而类与类之间共性的问题可以使
用来表示。继承在一定程度上可以实现复用，但是继承是类与类之间的强耦合，
如果可以不用继承就可以实现复用，则优先使用非继承方式。